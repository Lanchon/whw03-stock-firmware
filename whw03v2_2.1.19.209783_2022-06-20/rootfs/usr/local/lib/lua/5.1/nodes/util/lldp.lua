--
-- Copyright (c) 2017, Belkin Inc. All rights reserved.
--
-- LLDP support functions
--! @file
--! @brief LLDP utility functions for Nodes

module( ..., package.seeall )



Lldp = {
   -- Note: By exposing our exception strings here, we can write unit
   -- tests that use them.  See unit-tests/lldp_spec.lua
   ERROR = {
      MISSING_OR_NIL_ARGUMENT = "Missing or nil argument",
      BAD_ARGUMENT_TYPE       = "Bad argument type",
      WRONG_ARGUMENT_COUNT    = "Wrong argument count",
      BAD_NODE_MODE           = "Bad Node mode",
   },
   data = {}
}
Lldp_mt = {
   __index = function( t, k )
      return rawget( Lldp, k ) or rawget( rawget(t, "data" ), k )
   end
}

-- For class method convenience
local ERROR = Lldp.ERROR

--! @brief Encapsulate LLDP status into a table for JSON generation.
--! @param lldp A parsed table of lldp data such as generated by
--! load_status_file()
--! @return A Lua table with names and a structure that is consistent
--! with other omsg JSON payloads.
function Lldp:json_encapsulate()
   if not self.data then error "Incomplete Lldp object" end

   local json = {
      uuid = self.octets_to_uuid( self.uuid ),
      TS   = os.date( "!%FT%TZ" ),
      type = "status",
      data = {
         chassis_descr   = self["chassis.descr"],
         chassis_mgmt_ip = self["chassis.mgmt-ip"],
         chassis_name    = self["chassis.name"],
         port_descrt     = self["port.descrt"],
         port_mac        = self["port.mac"],
         port_recv       = self["port.recv"],
         root_accessible = tonumber( self.ra ) > 0,
      }
   }
   if self.mode then json.data.mode = self.mode_name( self.mode ) end
   if self.rip  then json.data.root_ip = self.octets_to_ip( self.rip )  end
   return json
end

--! @brief Load and parse an LLDP status file
--! @param fname Path to file
--! @return A table with name, value pairs corresponding to the lines
--! in the file
local function load_status_file( fname )
   local data = {}

   for line in io.lines(fname) do
      local name, value = line:match('^([^=]+)=(.*)$')
      data[name]=value
   end

   return data
end

--! @brief Convert a CSV sequence to an array.
--! A string containing a sequence of comma separated hexadecimal
--! values gets split into an array of numbers containing each value
--! (without the commas)
--! @param csv A string containing hex values.  E.g. "1a,4,7e,12"
--! @return An array of numbers.  The above would yield: { 170, 4, 126, 18 }
function Lldp.csv_to_hex_array( csv )
   --print( "csv:", csv )
   if not csv then error( ERROR.MISSING_OR_NIL_ARGUMENT, 2 ) end
   if type( csv ) ~= 'string' then error( ERROR.BAD_ARGUMENT_TYPE, 2 ) end
   local t = {}
   for val in csv:gmatch( '([^,]+)' ) do
      table.insert( t, tonumber( val, 16 ))
   end
   return t
end

--! @privatesection
-- Constants for octets_to_uuid
-- Build a format to generate 5A69FB54-0A70-4749-8FCD-0016B6297F24
local HEX2="%02X" -- 2 hex digits
local HEX4=HEX2:rep(2)
local TRIPLE_HEX4=table.concat({ HEX4, HEX4, HEX4 }, '-')
local FMT_OCTETS_TO_UUID=HEX2:rep(4)..'-'..TRIPLE_HEX4..'-'..HEX2:rep(6)
local DEC="%d"
local FMT_OCTETS_TO_IP=table.concat({ DEC, DEC, DEC, DEC }, ".")
--! @publicsection

--! @brief Convert an array of numbers to a UUID
--! @param s String containing CSV hex digits
--! @return A UUID in cacnonical format
function Lldp.octets_to_uuid( s )
   if not s then error( ERROR.MISSING_OR_NIL_ARGUMENT ) end
   local octets = Lldp.csv_to_hex_array( tostring( s ))
   if #octets ~= 16 then error( ERROR.WRONG_ARGUMENT_COUNT, 2 ) end
   return FMT_OCTETS_TO_UUID:format( unpack( octets ))
end


--! @brief Convert an array of numbers to an IP
function Lldp.octets_to_ip( s )
   if not s then error( ERROR.MISSING_OR_NIL_ARGUMENT, 2 ) end
   local octets = Lldp.csv_to_hex_array( tostring( s ))
   if #octets ~= 4 then error( ERROR.WRONG_ARGUMENT_COUNT, 2 ) end
   return FMT_OCTETS_TO_IP:format( unpack( octets ))
end

local NODE_MODE = {
   ID = {
      MASTER       = 2,
      SLAVE        = 1,
      UNCONFIGURED = 0
   },
   NAME = {}
}

NODE_MODE.NAME[NODE_MODE.ID.MASTER]       = "Master"
NODE_MODE.NAME[NODE_MODE.ID.SLAVE]        = "Slave"
NODE_MODE.NAME[NODE_MODE.ID.UNCONFIGURED] = "Unconfigured"

--! @brief Convert a numeric Node mode to a string.
--! @param mode Numeric Nodes mode value
--! @return a Lua string as defined in the above table
function Lldp.mode_name( mode )
   return NODE_MODE.NAME[tonumber(mode)] or "Unknown"
end




function Lldp:new(s)
   if not s then error( self.ERROR.MISSING_OR_NIL_ARGUMENT, 2 ) end
   local o = {
      data = load_status_file( s )
   }
   return setmetatable(  o, Lldp_mt )
end

return Lldp
